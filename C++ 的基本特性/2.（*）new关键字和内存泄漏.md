# new
1. new 自动计算所需分配内存的大小，malloc 需要手动计算；
2. new 返回对象类型的指针， 返回的是 void*（之后要进行类型转换）。
3. new 分配失败会抛出异常，malloc 失败返回 NULL
4. malloc 分配的是虚拟内存，小于128kb通过 brk 系统调用在堆上分配 （很小的内存还会直接从内存值中分配），大于的用 mmap 在文件映射区分配。
---
<details>
  <summary>引申</summary>
  1. malloc 分配的数据不会马上拥有物理内存，因为最开始不会被初始化，未被初始化的全局变量和静态变量会被存储在未初始化数据段（bss段）中，当程序中的变量被初始化后，它们所占用的虚拟内存空间可以通过缺页中断机制映射到物理内存中。<br> 
  2. new在一个通常被称为 free store 的自由存储区(堆区)分配；<br>
  3. 当使用 new 关键字在C++中分配内存时，操作系统会在虚拟内存中为这块内存分配相应的地址空间，但并不保证会立即分配物理内存。实际的物理内存分配可能会延迟到程序首次访问这块内存时才进行（懒加载），这种延迟分配的方式称为虚拟内存的延迟分配策略。这种延迟分配的策略可以提高内存的利用效率，避免不必要的物理内存分配。<br>
  4. delete 需要对象类型的指针， free 是 void* 类型的指针；<br>
  5. （*）free 如何知道该释放多大的空间？malloc分配空间是会多分配16个字节，返回的是16个字节之后的内存的首地址，free 的时候会左偏移16个字节，这些字节存储的是这个内存块的描述信息，其中包含了长度信息。<br>
  6. free 释放内存后，如果是通过brk分配的或者从内存值中分配的，那么释放的内存只是回到了内存值里，等待重新写入。<br>
  7. 通过 mmap 分配的内存释放后会立刻被释放。
</details>

---

new可以直接分配单个变量的内存，也可以分配数组。

在分配单个对象的内存时。
当对象是普通变量时，可以分配对应的内存
当对象是类对象时，会调用构造函数，如果没有对应的构造函数，就会报错。

在分配数组对象内存时：
对于普通变量：可以使用“（）”将所有对象全部初始化为0。
对于类对象，有没有“（）”都一样，均使用默认构造函数，如果没有默认构造函数就会报错。

**内存泄露介绍**：内存泄露是经常出现的常见bug：  
内存泄露会导致堆内存的逐渐被占用，最终内存用完程序崩溃。常见的情况就是项目测试没问题，上线几天就炸了。然后就会非常麻烦，排查困难，损失很大。  
**内存泄露是最严重的错误之一，程序不怕报错，就怕一开始运行的好好的，突然就出现了莫名其妙的错误。  
这句话也引出了后面的两个部分**。  
**Part4** 的智能指针可以非常好的避免内存泄露的问题。  
**Part9** 的异常处理部分可以恰当的处理程序出现的异常，让程序有错误就立马处理，或直接终止进程，或忽略，不要让异常莫名其妙。这是程序设计的重要理念。  
